# Value Converter

As soon as we changed our Grid type to use a Dynamic collection, it stopped loading. The error is hiding down here in this AJAX call. The best way to see it is to actually click the URL in a new tab. There we go - `Value converter for "App\Entity\Recipe" type does not exist.` Okay, so far, we've created a custom value type for `Recipe`, which was just this config here, and we created a custom query type which allows us to load a list of the latest recipes by running the query inside of the associated class. *Now* we're getting this value converter error. A value converter is really simple. It's a class that transforms the underlying object - `Recipe` - into a format that Layouts can understand. So in that same `/src/Layouts` directory, let's create a `RecipeValueConverter` and make this implement `ValueConverterInterface`. This is great, because I can now go to Code Generate (or "command" + "N" on a Mac) and hit "Implement Methods" to implement the seven we need. I know that sounds like a lot, but these are really easy to fill in.

First, for `supports()`, Layouts will call our `RecipeValueConverter` every time it has a value it doesn't understand. We want to tell it which type we support, and in this case, we support the `$object` if it's an `instanceof` `Recipe`.

Second, for `getValueType()`, we're actually going to `return` the internal key of our value type - `doctrine_recipe`.

Next is `getId()`, and we're literally just going to `return` our ID with `$object->getId()`. We don't have autocomplete on this, but we know that this object is going to be a recipe.

For `getRemoteId()`, just `return $this->getId($object)`. This is only relevant if you are trying to move content between databases.

Down here, for `getName()`, this is just going to be a human-readable name that's going to be shown, for example, in the admin area. This time, to help out my editor, I'm going to add a little `assert()` function and say `$object instanceof Recipe`. There are two things to note here. First, we *know* that this object will always be a `Recipe` because, up in `supports()`, we said that's the only type we'll support. If you haven't seen this `assert()` function before, if the `$object` is *not* an `instanceof` a recipe, it will throw an exception. It's a really easy way to tell your editor or other tools like PHPStan that the object is *definitely* an `instanceof Recipe`. That's nice, because now, we'll get an autocompletion when we say `return $object->getName()`.

Next is `getIsVisible()`. Let's `return true`. If your recipes could be published or unpublished,for example, then you could check that here and return `true` or `false`.

Finally, for `getObject()`, we'll `return $object`. I know that seems a little silly, but this is a handy way for you to change your recipe after it's loaded if you wanted to add more stuff to it. That's not something that we *need* to do, just a convenience for our users. And... we're finished! *Sweet*.

This time, unlike the query type handler, auto-configuration takes care of *everything*, so we don't need to add a manual tag up here. If we move over, I'll try refreshing this AJAX endpoint first and... that works! Let's go over here and refresh our layouts admin page again. And... *whoa*. Check it out! You can see a bunch of items on our Grid. If we click it, we can see our items loading below. That's awesome!

~~~~~

Now notice we only ever had to choose dynamic collection. We didn't actually ever have to choose that we were specifically using our latest recipes query type. That's simply because it's the only query type in our system. If we added a second query type in our system, we would see another drop down here where we could slack between maybe latest recipes and most popular recipes. So this is using our latest recipes query type to get all 25 of these results. So for example, if we're trying to recreate this area here, we only want four. So let's limit the number of items to four. Awesome.

All right, let's see what this looks like on the front end. I'm hit publish and continue editing And once that saves, we'll go over and refresh. It should show up right here and we see absolutely nothing, or at least it seems like that at first. But if you zoom in here a little bit, let's see, you can see we have a diviv here call that has a class VT grid on it and inside a row and inside of that we see a bunch of empty diffs. If you ignore this clear fix here we have 1, 2, 3, 4. So the items are rendering there, They're just rendering empty. And that makes sense. We haven't told layouts how recipe items should be rendered yet. More on that in a few minutes. But before we get there, I wanna make our query type a bit fancier. So notice there's this one method called it build parameters that we ignored. This is a way for us to add extra form fields to allow our query to be modified by the admin. For example, if we wanted to, we could add like a search term so that we could return the latest recipes that match a certain term. So to do that, we could say builder, add term and they'll say text type and get the one from neck and layouts, parameters, types. There's several different built in form field types that you can use. Perfect with just that, we go and refresh our admin now and click down here on grid. Sweet. We've got a big new box here. Of course, if we type anything on here, nothing happens. And it also has a really weird label.

So let's fix that label first. It's got this weird label so that um, we can translate it. So what we do, this is in the translations directory that's being translated through a domain called NNG layouts. So we can create a file called nng layouts dot en.dot Yaml. By the way, a really easy way to know that that's the domain you need to use is to leverage. No, nevermind, I'm not gonna talk about that. And so here I'll paste and we'll set that to search term. Now if we refresh that right now and click it works, for some reason you're don't see the translation there, try clearing your cash now to actually make that do something, modify the query over in our query type handler, this query object that we're passed from layouts that contains this value. So our create query builder ordered by newest actually already has an optional search term that we can pass into it. So here we can pass query arrow, get parameter, and then type, type and term and then get value. So I'm gonna copy that and we'll repeat that down here for our count. Awesome, let's try that. Refresh the layouts area, go down here and sweet. Consider there's no items. Cause I have this silly search term if I'll clear it out. We get everything. All right. Just type couple letters into there. You can see it changing below. Awesome.

Next, let's teach layouts how to render the recipe items both on the front end as well as the back end preview.
