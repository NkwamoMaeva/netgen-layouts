# Value Type

We have a recipe entity and on the front end, a page with a list of recipes, and we saw how we can easily transform this page into a layout, which instantly makes parts of it configurable. But looking at the homepage now, I wonder if we can add more complex blocks beyond just text. Could we, for example, add a block that dynamically renders the list of recipes? Something similar to what we have here right now, except instead of adding this via our Twig template, add it via layouts? If we *could*, we could recreate this, but give our admin users control over which recipes show here. If the first big idea for Layouts was allowing the layouts to be rearranged and mixed with dynamic content, then the second big idea is allowing pieces of *existing* content, like recipes, to be embedded onto our page via the Layout system.

Let's edit the homepage layout. In our list of blocks on the left, check out this "Grid" option. Let's add that right here after our "Hero" Twig block. The Grid allows us to add individual items to it, but... I don't see a way to do that. We know that we can add a lot of cool blocks, like titles, maps, markdown, to the page right out of the box. *But* some blocks like List, Grid, and the Gallery blocks down here (which are just fancy grids that have some JavaScript behavior attached to them) contain dynamic items that are loaded from *somewhere else*, like our local database, CMS, or even Sylius if you're using Layouts on a Sylius project. All of these things we can add to the blocks are called "value types". We currently have *zero*. If this were a Sylius project, we could install Sylius and Layouts integration and instantly be able to select products. The same is true if you're using Ibexa CMS.

So here's our next big goal: To add our recipe doctrine entity layouts as a value type so we can create lists and grids containing recipes. Step one to adding a value type is to tell Layouts about it in a config file. So over in `/config/packages/netgen_layouts.php`, very simply, we say `value_types`, and below that, `doctrine_recipe `. This will be the internal name of the value type, and we'll refer to it in a few places. I'll give it a nice human-friendly `name` - `Recipe` - and for now, `manual_items: false`. We'll talk about the `manual_items` thing later. Whoops... Make sure this is *items* with a "s". It's easier to set this to `false `to start with. If we head over and refresh our layouts page (it's okay to reload it)... check out our Grid block! We have a collection type, and "Manual collection" is our only option right now. So... this still doesn't seem to be working. I can't change this to anything else, and I also can't select items manually.

There are two ways to add items to a collection block. The first is a *dynamic* collection where we choose from a pre-made query. We could choose from a something like "Most Popular", for example, that would automatically query for the most popular or latest recipes. The *second* way to choose items is by *manually* choosing them. Eventually, we'll be able to pick out the exact recipes we want to go into one of these blocks.

We're going to start with the first type: The *dynamic* collection. We don't see "Dynamic collection" as an option here yet because we need to create one of those pre-made queries first. Those pre-made queries are called `query_types`. We could, for instance, create a query type for `Recipe` called "Most Popular" and another one called "Latest". How do we create these query types? We need to head back over to our `/config` file, add `query_types` and below that, let's say `latest_recipes`. Once again, this is going to be an internal key here, so we'll give it a human-readable `name` - `Latest Recipes`.

So... what do we do now? If we head back and refresh... we get a very nice error that tells us what to do next: `Query type handler for "latest_recipes" query type does not exist.` We need a class to represent this query type! Awesome!

Over in the `/src` directory, I'm going to create a new `/Layouts` directory. We'll be organizing a lot of our custom layout stuff inside of here. I'll create a new PHP class called... how about `LatestRecipeQueryTypeHandler`. Then, let's make this implement `QueryTypeHandlerInterface`. Nice! Next, I'll go to "Code Generate" (or "command" + "N" on a Mac), and go to "Implement Methods" to implement the four methods that we need. Cool!

Our job in here is pretty simple. I'll leave `buildParameters()` empty for a second. We'll talk about that in a minute. The most important thing here is called `getvalues()`. This is where we're actually going to make the query for the recipes and return them. To do that, I'm going to go to the top of the class, add a `__construct()` method, and we'll say `private RecipeRepository $recipeRepository` so I can use my `RecipeRepository` to make my queries. Then, down in `getValues()`, I'll `return $this->recipeRepository`, and I'm going to call a method on this that I've already created inside of `RecipeRepository` called `->createQueryBuilderOrderedByNewest()`. That creates a QueryBuilder. Then we can say `->setFirstResult()` and pass it `$offset`, and below that, `->setMaxResults()` and pass `$limit`. You'll see why these are passed in a second. As an admin, we can control how many it should return and if it should skip the first two, for example. We feed those into our query. Finally, we'll say `->getQuery()` and `->getResult()`. Perfect!

Down here... for `getCount()`, we'll do the exact same thing, except we don't need the `->setMaxResults()` or `->setFirstResults()`. Instead, we're going to say `->select('COUNT(recipe.id)')`. I'm using `recipe` here because, over in `RecipeRepository`, if we look at the custom method we added here, we're using `recipe`, the alias in my query. After that, let's update this `->getResult()` to say `->getSingleScalarResult()`. That was a little bit of work, but it's fairly straightforward. It's pretty much the same query two different times. This time is just getting the count. For `isContextual()`, I'm going to `return false`.

That's *it*. This is now a functional query type handler. But if you go over and refresh... it *still* doesn't work. We get the *same* error. That's because we need to associate this query type handler class with the `latest_recipes` query type in our config. To do that, we need to give this service a tag, and there's a really cool new way to do this, thanks to Symphony 6.1.

We're going to add an attribute above our class called `#[AutoconfigureTag()]`, and the name of the tag we need here is called `netgen_layouts.query_type_handler`. This is straight out of the documentation. We also need to pass this an array with a `type` key set to `latest_recipes`. It's important that his `type` here matches up with what we have in our config so it ties these two things together. And now... the page *works*! If we click on our Grid block... we can switch to "Dynamic collection". *Awesome*! I'll hit apply and... everything immediately stops loading.

When you have an error in the admin section, there's a good chance it will show up via an AJAX call. If you look down here on the web debug toolbar, we have a 400 Error that just happened. Let's fix that next by creating a *value converter*. Then we'll make our query *even smarter*.
